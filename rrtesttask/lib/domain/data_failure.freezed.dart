// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'data_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$DataFailureTearOff {
  const _$DataFailureTearOff();

  DataFailureNoError noError() {
    return const DataFailureNoError();
  }

  DataFailureNoData noData() {
    return const DataFailureNoData();
  }

  DataFailureCancelled cancelled() {
    return const DataFailureCancelled();
  }

  DataFailureBadRequest badRequest() {
    return const DataFailureBadRequest();
  }

  DataFailureUnauthorized unauthorized() {
    return const DataFailureUnauthorized();
  }

  DataFailureForbidden forbidden() {
    return const DataFailureForbidden();
  }

  DataFailureServerError serverError() {
    return const DataFailureServerError();
  }
}

/// @nodoc
const $DataFailure = _$DataFailureTearOff();

/// @nodoc
mixin _$DataFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noError,
    required TResult Function() noData,
    required TResult Function() cancelled,
    required TResult Function() badRequest,
    required TResult Function() unauthorized,
    required TResult Function() forbidden,
    required TResult Function() serverError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataFailureNoError value) noError,
    required TResult Function(DataFailureNoData value) noData,
    required TResult Function(DataFailureCancelled value) cancelled,
    required TResult Function(DataFailureBadRequest value) badRequest,
    required TResult Function(DataFailureUnauthorized value) unauthorized,
    required TResult Function(DataFailureForbidden value) forbidden,
    required TResult Function(DataFailureServerError value) serverError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataFailureCopyWith<$Res> {
  factory $DataFailureCopyWith(
          DataFailure value, $Res Function(DataFailure) then) =
      _$DataFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$DataFailureCopyWithImpl<$Res> implements $DataFailureCopyWith<$Res> {
  _$DataFailureCopyWithImpl(this._value, this._then);

  final DataFailure _value;
  // ignore: unused_field
  final $Res Function(DataFailure) _then;
}

/// @nodoc
abstract class $DataFailureNoErrorCopyWith<$Res> {
  factory $DataFailureNoErrorCopyWith(
          DataFailureNoError value, $Res Function(DataFailureNoError) then) =
      _$DataFailureNoErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$DataFailureNoErrorCopyWithImpl<$Res>
    extends _$DataFailureCopyWithImpl<$Res>
    implements $DataFailureNoErrorCopyWith<$Res> {
  _$DataFailureNoErrorCopyWithImpl(
      DataFailureNoError _value, $Res Function(DataFailureNoError) _then)
      : super(_value, (v) => _then(v as DataFailureNoError));

  @override
  DataFailureNoError get _value => super._value as DataFailureNoError;
}

/// @nodoc

class _$DataFailureNoError implements DataFailureNoError {
  const _$DataFailureNoError();

  @override
  String toString() {
    return 'DataFailure.noError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DataFailureNoError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noError,
    required TResult Function() noData,
    required TResult Function() cancelled,
    required TResult Function() badRequest,
    required TResult Function() unauthorized,
    required TResult Function() forbidden,
    required TResult Function() serverError,
  }) {
    return noError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
  }) {
    return noError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
    required TResult orElse(),
  }) {
    if (noError != null) {
      return noError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataFailureNoError value) noError,
    required TResult Function(DataFailureNoData value) noData,
    required TResult Function(DataFailureCancelled value) cancelled,
    required TResult Function(DataFailureBadRequest value) badRequest,
    required TResult Function(DataFailureUnauthorized value) unauthorized,
    required TResult Function(DataFailureForbidden value) forbidden,
    required TResult Function(DataFailureServerError value) serverError,
  }) {
    return noError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
  }) {
    return noError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
    required TResult orElse(),
  }) {
    if (noError != null) {
      return noError(this);
    }
    return orElse();
  }
}

abstract class DataFailureNoError implements DataFailure {
  const factory DataFailureNoError() = _$DataFailureNoError;
}

/// @nodoc
abstract class $DataFailureNoDataCopyWith<$Res> {
  factory $DataFailureNoDataCopyWith(
          DataFailureNoData value, $Res Function(DataFailureNoData) then) =
      _$DataFailureNoDataCopyWithImpl<$Res>;
}

/// @nodoc
class _$DataFailureNoDataCopyWithImpl<$Res>
    extends _$DataFailureCopyWithImpl<$Res>
    implements $DataFailureNoDataCopyWith<$Res> {
  _$DataFailureNoDataCopyWithImpl(
      DataFailureNoData _value, $Res Function(DataFailureNoData) _then)
      : super(_value, (v) => _then(v as DataFailureNoData));

  @override
  DataFailureNoData get _value => super._value as DataFailureNoData;
}

/// @nodoc

class _$DataFailureNoData implements DataFailureNoData {
  const _$DataFailureNoData();

  @override
  String toString() {
    return 'DataFailure.noData()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DataFailureNoData);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noError,
    required TResult Function() noData,
    required TResult Function() cancelled,
    required TResult Function() badRequest,
    required TResult Function() unauthorized,
    required TResult Function() forbidden,
    required TResult Function() serverError,
  }) {
    return noData();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
  }) {
    return noData?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
    required TResult orElse(),
  }) {
    if (noData != null) {
      return noData();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataFailureNoError value) noError,
    required TResult Function(DataFailureNoData value) noData,
    required TResult Function(DataFailureCancelled value) cancelled,
    required TResult Function(DataFailureBadRequest value) badRequest,
    required TResult Function(DataFailureUnauthorized value) unauthorized,
    required TResult Function(DataFailureForbidden value) forbidden,
    required TResult Function(DataFailureServerError value) serverError,
  }) {
    return noData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
  }) {
    return noData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
    required TResult orElse(),
  }) {
    if (noData != null) {
      return noData(this);
    }
    return orElse();
  }
}

abstract class DataFailureNoData implements DataFailure {
  const factory DataFailureNoData() = _$DataFailureNoData;
}

/// @nodoc
abstract class $DataFailureCancelledCopyWith<$Res> {
  factory $DataFailureCancelledCopyWith(DataFailureCancelled value,
          $Res Function(DataFailureCancelled) then) =
      _$DataFailureCancelledCopyWithImpl<$Res>;
}

/// @nodoc
class _$DataFailureCancelledCopyWithImpl<$Res>
    extends _$DataFailureCopyWithImpl<$Res>
    implements $DataFailureCancelledCopyWith<$Res> {
  _$DataFailureCancelledCopyWithImpl(
      DataFailureCancelled _value, $Res Function(DataFailureCancelled) _then)
      : super(_value, (v) => _then(v as DataFailureCancelled));

  @override
  DataFailureCancelled get _value => super._value as DataFailureCancelled;
}

/// @nodoc

class _$DataFailureCancelled implements DataFailureCancelled {
  const _$DataFailureCancelled();

  @override
  String toString() {
    return 'DataFailure.cancelled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DataFailureCancelled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noError,
    required TResult Function() noData,
    required TResult Function() cancelled,
    required TResult Function() badRequest,
    required TResult Function() unauthorized,
    required TResult Function() forbidden,
    required TResult Function() serverError,
  }) {
    return cancelled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
  }) {
    return cancelled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataFailureNoError value) noError,
    required TResult Function(DataFailureNoData value) noData,
    required TResult Function(DataFailureCancelled value) cancelled,
    required TResult Function(DataFailureBadRequest value) badRequest,
    required TResult Function(DataFailureUnauthorized value) unauthorized,
    required TResult Function(DataFailureForbidden value) forbidden,
    required TResult Function(DataFailureServerError value) serverError,
  }) {
    return cancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
  }) {
    return cancelled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled(this);
    }
    return orElse();
  }
}

abstract class DataFailureCancelled implements DataFailure {
  const factory DataFailureCancelled() = _$DataFailureCancelled;
}

/// @nodoc
abstract class $DataFailureBadRequestCopyWith<$Res> {
  factory $DataFailureBadRequestCopyWith(DataFailureBadRequest value,
          $Res Function(DataFailureBadRequest) then) =
      _$DataFailureBadRequestCopyWithImpl<$Res>;
}

/// @nodoc
class _$DataFailureBadRequestCopyWithImpl<$Res>
    extends _$DataFailureCopyWithImpl<$Res>
    implements $DataFailureBadRequestCopyWith<$Res> {
  _$DataFailureBadRequestCopyWithImpl(
      DataFailureBadRequest _value, $Res Function(DataFailureBadRequest) _then)
      : super(_value, (v) => _then(v as DataFailureBadRequest));

  @override
  DataFailureBadRequest get _value => super._value as DataFailureBadRequest;
}

/// @nodoc

class _$DataFailureBadRequest implements DataFailureBadRequest {
  const _$DataFailureBadRequest();

  @override
  String toString() {
    return 'DataFailure.badRequest()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DataFailureBadRequest);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noError,
    required TResult Function() noData,
    required TResult Function() cancelled,
    required TResult Function() badRequest,
    required TResult Function() unauthorized,
    required TResult Function() forbidden,
    required TResult Function() serverError,
  }) {
    return badRequest();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
  }) {
    return badRequest?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
    required TResult orElse(),
  }) {
    if (badRequest != null) {
      return badRequest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataFailureNoError value) noError,
    required TResult Function(DataFailureNoData value) noData,
    required TResult Function(DataFailureCancelled value) cancelled,
    required TResult Function(DataFailureBadRequest value) badRequest,
    required TResult Function(DataFailureUnauthorized value) unauthorized,
    required TResult Function(DataFailureForbidden value) forbidden,
    required TResult Function(DataFailureServerError value) serverError,
  }) {
    return badRequest(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
  }) {
    return badRequest?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
    required TResult orElse(),
  }) {
    if (badRequest != null) {
      return badRequest(this);
    }
    return orElse();
  }
}

abstract class DataFailureBadRequest implements DataFailure {
  const factory DataFailureBadRequest() = _$DataFailureBadRequest;
}

/// @nodoc
abstract class $DataFailureUnauthorizedCopyWith<$Res> {
  factory $DataFailureUnauthorizedCopyWith(DataFailureUnauthorized value,
          $Res Function(DataFailureUnauthorized) then) =
      _$DataFailureUnauthorizedCopyWithImpl<$Res>;
}

/// @nodoc
class _$DataFailureUnauthorizedCopyWithImpl<$Res>
    extends _$DataFailureCopyWithImpl<$Res>
    implements $DataFailureUnauthorizedCopyWith<$Res> {
  _$DataFailureUnauthorizedCopyWithImpl(DataFailureUnauthorized _value,
      $Res Function(DataFailureUnauthorized) _then)
      : super(_value, (v) => _then(v as DataFailureUnauthorized));

  @override
  DataFailureUnauthorized get _value => super._value as DataFailureUnauthorized;
}

/// @nodoc

class _$DataFailureUnauthorized implements DataFailureUnauthorized {
  const _$DataFailureUnauthorized();

  @override
  String toString() {
    return 'DataFailure.unauthorized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DataFailureUnauthorized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noError,
    required TResult Function() noData,
    required TResult Function() cancelled,
    required TResult Function() badRequest,
    required TResult Function() unauthorized,
    required TResult Function() forbidden,
    required TResult Function() serverError,
  }) {
    return unauthorized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
  }) {
    return unauthorized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataFailureNoError value) noError,
    required TResult Function(DataFailureNoData value) noData,
    required TResult Function(DataFailureCancelled value) cancelled,
    required TResult Function(DataFailureBadRequest value) badRequest,
    required TResult Function(DataFailureUnauthorized value) unauthorized,
    required TResult Function(DataFailureForbidden value) forbidden,
    required TResult Function(DataFailureServerError value) serverError,
  }) {
    return unauthorized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
  }) {
    return unauthorized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized(this);
    }
    return orElse();
  }
}

abstract class DataFailureUnauthorized implements DataFailure {
  const factory DataFailureUnauthorized() = _$DataFailureUnauthorized;
}

/// @nodoc
abstract class $DataFailureForbiddenCopyWith<$Res> {
  factory $DataFailureForbiddenCopyWith(DataFailureForbidden value,
          $Res Function(DataFailureForbidden) then) =
      _$DataFailureForbiddenCopyWithImpl<$Res>;
}

/// @nodoc
class _$DataFailureForbiddenCopyWithImpl<$Res>
    extends _$DataFailureCopyWithImpl<$Res>
    implements $DataFailureForbiddenCopyWith<$Res> {
  _$DataFailureForbiddenCopyWithImpl(
      DataFailureForbidden _value, $Res Function(DataFailureForbidden) _then)
      : super(_value, (v) => _then(v as DataFailureForbidden));

  @override
  DataFailureForbidden get _value => super._value as DataFailureForbidden;
}

/// @nodoc

class _$DataFailureForbidden implements DataFailureForbidden {
  const _$DataFailureForbidden();

  @override
  String toString() {
    return 'DataFailure.forbidden()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DataFailureForbidden);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noError,
    required TResult Function() noData,
    required TResult Function() cancelled,
    required TResult Function() badRequest,
    required TResult Function() unauthorized,
    required TResult Function() forbidden,
    required TResult Function() serverError,
  }) {
    return forbidden();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
  }) {
    return forbidden?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
    required TResult orElse(),
  }) {
    if (forbidden != null) {
      return forbidden();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataFailureNoError value) noError,
    required TResult Function(DataFailureNoData value) noData,
    required TResult Function(DataFailureCancelled value) cancelled,
    required TResult Function(DataFailureBadRequest value) badRequest,
    required TResult Function(DataFailureUnauthorized value) unauthorized,
    required TResult Function(DataFailureForbidden value) forbidden,
    required TResult Function(DataFailureServerError value) serverError,
  }) {
    return forbidden(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
  }) {
    return forbidden?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
    required TResult orElse(),
  }) {
    if (forbidden != null) {
      return forbidden(this);
    }
    return orElse();
  }
}

abstract class DataFailureForbidden implements DataFailure {
  const factory DataFailureForbidden() = _$DataFailureForbidden;
}

/// @nodoc
abstract class $DataFailureServerErrorCopyWith<$Res> {
  factory $DataFailureServerErrorCopyWith(DataFailureServerError value,
          $Res Function(DataFailureServerError) then) =
      _$DataFailureServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$DataFailureServerErrorCopyWithImpl<$Res>
    extends _$DataFailureCopyWithImpl<$Res>
    implements $DataFailureServerErrorCopyWith<$Res> {
  _$DataFailureServerErrorCopyWithImpl(DataFailureServerError _value,
      $Res Function(DataFailureServerError) _then)
      : super(_value, (v) => _then(v as DataFailureServerError));

  @override
  DataFailureServerError get _value => super._value as DataFailureServerError;
}

/// @nodoc

class _$DataFailureServerError implements DataFailureServerError {
  const _$DataFailureServerError();

  @override
  String toString() {
    return 'DataFailure.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DataFailureServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noError,
    required TResult Function() noData,
    required TResult Function() cancelled,
    required TResult Function() badRequest,
    required TResult Function() unauthorized,
    required TResult Function() forbidden,
    required TResult Function() serverError,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noError,
    TResult Function()? noData,
    TResult Function()? cancelled,
    TResult Function()? badRequest,
    TResult Function()? unauthorized,
    TResult Function()? forbidden,
    TResult Function()? serverError,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataFailureNoError value) noError,
    required TResult Function(DataFailureNoData value) noData,
    required TResult Function(DataFailureCancelled value) cancelled,
    required TResult Function(DataFailureBadRequest value) badRequest,
    required TResult Function(DataFailureUnauthorized value) unauthorized,
    required TResult Function(DataFailureForbidden value) forbidden,
    required TResult Function(DataFailureServerError value) serverError,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataFailureNoError value)? noError,
    TResult Function(DataFailureNoData value)? noData,
    TResult Function(DataFailureCancelled value)? cancelled,
    TResult Function(DataFailureBadRequest value)? badRequest,
    TResult Function(DataFailureUnauthorized value)? unauthorized,
    TResult Function(DataFailureForbidden value)? forbidden,
    TResult Function(DataFailureServerError value)? serverError,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class DataFailureServerError implements DataFailure {
  const factory DataFailureServerError() = _$DataFailureServerError;
}
